export function updateJointAnimation(
  now,
  rotatetableREF,
  object3DtableREF,
  targetMoveDistanceRef,
  target_move_speed,
  max_move_unit,
  toAngle,
  toRadian,
  rotvec_table
) {
  for (let i = 0; i < rotatetableREF.current.length; i++) {
    const current_table = rotatetableREF.current[i];
    const current_object3D = object3DtableREF.current[i];
    if (!current_object3D) continue;
    if (current_table.length > 0) {
      const current_data = current_table[0];
      if (current_data.first) {
        current_data.first = false;
        current_data.starttime = performance.now();
        current_data.start_quaternion = current_object3D.quaternion.clone();
        current_data.end_quaternion = new THREE.Quaternion().setFromAxisAngle(
          rotvec_table[i],
          toRadian(current_data.rot)
        );
        const move_time_1 = targetMoveDistanceRef.current * target_move_speed;
        const wk_euler = new THREE.Quaternion().angleTo(
          current_data.start_quaternion.clone().invert().multiply(current_data.end_quaternion)
        );
        const move_time_2 = toAngle(wk_euler) * max_move_unit * 1000;
        current_data.move_time = Math.max(move_time_1, move_time_2);
        current_data.endtime = current_data.starttime + current_data.move_time;
      }
      const current_time = performance.now();
      if (current_time < current_data.endtime) {
        const elapsed_time = current_time - current_data.starttime;
        current_object3D.quaternion.slerpQuaternions(
          current_data.start_quaternion,
          current_data.end_quaternion,
          elapsed_time / current_data.move_time
        );
      } else {
        current_object3D.quaternion.copy(current_data.end_quaternion);
        current_table.shift();
      }
    }
  }
}